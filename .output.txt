
Restore complete (0.6s)
  WhereAreThey net10.0 succeeded (0.5s) → bin\Debug\net10.0\WhereAreThey.dll
  WhereAreThey.Tests net10.0 succeeded (0.3s) → WhereAreThey.Tests\bin\Debug\net10.0\WhereAreThey.Tests.dll
[xUnit.net 00:00:00.00] xUnit.net VSTest Adapter v3.1.4+50e68bbb8b (64-bit .NET 10.0.1)
[xUnit.net 00:00:00.09]   Discovering: WhereAreThey.Tests
[xUnit.net 00:00:00.15]   Discovered:  WhereAreThey.Tests
[xUnit.net 00:00:00.17]   Starting:    WhereAreThey.Tests
[xUnit.net 00:00:00.57]     WhereAreThey.Tests.DonationServiceTests.RecordDonation_ShouldSaveDonation [FAIL]
[xUnit.net 00:00:00.57]       System.ObjectDisposedException : Cannot access a disposed context instance. A common cause of this error is disposing a context instance that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling 'Dispose' on the context instance, or wrapping it in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.
[xUnit.net 00:00:00.57]       Object name: 'ApplicationDbContext'.
[xUnit.net 00:00:00.57]       Stack Trace:
[xUnit.net 00:00:00.57]            at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
[xUnit.net 00:00:00.57]            at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
[xUnit.net 00:00:00.57]            at Microsoft.EntityFrameworkCore.DbContext.Microsoft.EntityFrameworkCore.Internal.IDbContextDependencies.get_EntityFinderFactory()
[xUnit.net 00:00:00.57]            at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.get_Finder()
[xUnit.net 00:00:00.57]            at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.FindAsync(Object[] keyValues)
[xUnit.net 00:00:00.57]         C:\Code\wherearethey\WhereAreThey.Tests\DonationServiceTests.cs(58,0): at WhereAreThey.Tests.DonationServiceTests.RecordDonation_ShouldSaveDonation()
[xUnit.net 00:00:00.57]         --- End of stack trace from previous location ---
[xUnit.net 00:00:00.68]     WhereAreThey.Tests.DonationServiceTests.UpdateDonationStatus_ShouldUpdateStatus [FAIL]
[xUnit.net 00:00:00.68]       System.ObjectDisposedException : Cannot access a disposed context instance. A common cause of this error is disposing a context instance that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling 'Dispose' on the context instance, or wrapping it in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.
[xUnit.net 00:00:00.68]       Object name: 'ApplicationDbContext'.
[xUnit.net 00:00:00.68]       Stack Trace:
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.get_ChangeTracker()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.GenerateCacheKeyCore(Expression query, Boolean async)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.GenerateCacheKey(Expression query, Boolean async)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteCore[TResult](Expression query, Boolean async, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteAsync[TResult](Expression query, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryProvider.ExecuteAsync[TResult](Expression expression, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync[TSource,TResult](MethodInfo operatorMethodInfo, IQueryable`1 source, Expression expression, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ExecuteAsync[TSource,TResult](MethodInfo operatorMethodInfo, IQueryable`1 source, LambdaExpression expression, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.FirstAsync[TSource](IQueryable`1 source, Expression`1 predicate, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]         C:\Code\wherearethey\WhereAreThey.Tests\DonationServiceTests.cs(84,0): at WhereAreThey.Tests.DonationServiceTests.UpdateDonationStatus_ShouldUpdateStatus()
[xUnit.net 00:00:00.68]         --- End of stack trace from previous location ---
[xUnit.net 00:00:00.68]     WhereAreThey.Tests.AlertServiceTests.GetMatchingAlerts_ShouldReturnAlertsWithinRadius [FAIL]
[xUnit.net 00:00:00.68]       System.ObjectDisposedException : Cannot access a disposed context instance. A common cause of this error is disposing a context instance that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling 'Dispose' on the context instance, or wrapping it in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.
[xUnit.net 00:00:00.68]       Object name: 'ApplicationDbContext'.
[xUnit.net 00:00:00.68]       Stack Trace:
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.DbContext.get_ChangeTracker()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.GenerateCacheKeyCore(Expression query, Boolean async)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.GenerateCacheKey(Expression query, Boolean async)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteCore[TResult](Expression query, Boolean async, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteAsync[TResult](Expression query, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryProvider.ExecuteAsync[TResult](Expression expression, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1.GetAsyncEnumerator(CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]            at System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1.GetAsyncEnumerator()
[xUnit.net 00:00:00.68]            at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ToListAsync[TSource](IQueryable`1 source, CancellationToken cancellationToken)
[xUnit.net 00:00:00.68]         C:\Code\wherearethey\Services\AlertService.cs(52,0): at WhereAreThey.Services.AlertService.GetActiveAlertsAsync(String userIdentifier)
[xUnit.net 00:00:00.68]         C:\Code\wherearethey\Services\AlertService.cs(70,0): at WhereAreThey.Services.AlertService.GetMatchingAlertsAsync(Double latitude, Double longitude)
[xUnit.net 00:00:00.68]         C:\Code\wherearethey\WhereAreThey.Tests\AlertServiceTests.cs(196,0): at WhereAreThey.Tests.AlertServiceTests.GetMatchingAlerts_ShouldReturnAlertsWithinRadius()
[xUnit.net 00:00:00.68]         --- End of stack trace from previous location ---
[xUnit.net 00:00:00.69]     WhereAreThey.Tests.AlertServiceTests.CreateAlert_ShouldCapRadiusAt160_9 [FAIL]
[xUnit.net 00:00:00.69]       System.ObjectDisposedException : Cannot access a disposed context instance. A common cause of this error is disposing a context instance that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling 'Dispose' on the context instance, or wrapping it in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.
[xUnit.net 00:00:00.69]       Object name: 'ApplicationDbContext'.
[xUnit.net 00:00:00.69]       Stack Trace:
[xUnit.net 00:00:00.69]            at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
[xUnit.net 00:00:00.69]            at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
[xUnit.net 00:00:00.69]            at Microsoft.EntityFrameworkCore.DbContext.Microsoft.EntityFrameworkCore.Internal.IDbContextDependencies.get_EntityFinderFactory()
[xUnit.net 00:00:00.69]            at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.get_Finder()
[xUnit.net 00:00:00.69]            at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.FindAsync(Object[] keyValues)
[xUnit.net 00:00:00.69]         C:\Code\wherearethey\WhereAreThey.Tests\AlertServiceTests.cs(254,0): at WhereAreThey.Tests.AlertServiceTests.CreateAlert_ShouldCapRadiusAt160_9()
[xUnit.net 00:00:00.69]         --- End of stack trace from previous location ---
[xUnit.net 00:00:01.15]     WhereAreThey.Tests.LocationServiceTests.AddLocationReport_Integration_ShouldSendEmailToAlertSubscribers [FAIL]
[xUnit.net 00:00:01.15]       System.ObjectDisposedException : Cannot access a disposed context instance. A common cause of this error is disposing a context instance that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling 'Dispose' on the context instance, or wrapping it in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.
[xUnit.net 00:00:01.15]       Object name: 'ApplicationDbContext'.
[xUnit.net 00:00:01.15]       Stack Trace:
[xUnit.net 00:00:01.15]            at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
[xUnit.net 00:00:01.15]            at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
[xUnit.net 00:00:01.15]            at Microsoft.EntityFrameworkCore.DbContext.Microsoft.EntityFrameworkCore.Internal.IDbContextDependencies.get_StateManager()
[xUnit.net 00:00:01.15]            at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.EntryWithoutDetectChanges(TEntity entity)
[xUnit.net 00:00:01.15]            at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.Add(TEntity entity)
[xUnit.net 00:00:01.15]         C:\Code\wherearethey\Services\LocationService.cs(15,0): at WhereAreThey.Services.LocationService.AddLocationReportAsync(LocationReport report)
[xUnit.net 00:00:01.15]         C:\Code\wherearethey\WhereAreThey.Tests\LocationServiceTests.cs(292,0): at WhereAreThey.Tests.LocationServiceTests.AddLocationReport_Integration_ShouldSendEmailToAlertSubscribers()
[xUnit.net 00:00:01.15]         --- End of stack trace from previous location ---
[xUnit.net 00:00:01.17]   Finished:    WhereAreThey.Tests
  WhereAreThey.Tests test net10.0 failed with 5 error(s) (2.0s)
    C:\Code\wherearethey\WhereAreThey.Tests\DonationServiceTests.cs(58): error TESTERROR:
      WhereAreThey.Tests.DonationServiceTests.RecordDonation_ShouldSaveDonation
      (353ms): Error Message: System.ObjectDisposedException : Cannot access a d
      isposed context instance. A common cause of this error is disposing a cont
      ext instance that was resolved from dependency injection and then later tr
      ying to use the same context instance elsewhere in your application. This
      may occur if you are calling 'Dispose' on the context instance, or wrappin
      g it in a using statement. If you are using dependency injection, you shou
      ld let the dependency injection container take care of disposing context i
      nstances.
      Object name: 'ApplicationDbContext'.
      Stack Trace:
         at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
         at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
         at Microsoft.EntityFrameworkCore.DbContext.Microsoft.EntityFrameworkCor
      e.Internal.IDbContextDependencies.get_EntityFinderFactory()
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.get_Finder()
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.FindAsync(Obj
      ect[] keyValues)
         at WhereAreThey.Tests.DonationServiceTests.RecordDonation_ShouldSaveDon
      ation() in C:\Code\wherearethey\WhereAreThey.Tests\DonationServiceTests.cs
      :line 58
      --- End of stack trace from previous location ---
    C:\Code\wherearethey\WhereAreThey.Tests\DonationServiceTests.cs(84): error TESTERROR:
      WhereAreThey.Tests.DonationServiceTests.UpdateDonationStatus_ShouldUpdateS
      tatus (106ms): Error Message: System.ObjectDisposedException : Cannot acce
      ss a disposed context instance. A common cause of this error is disposing
      a context instance that was resolved from dependency injection and then la
      ter trying to use the same context instance elsewhere in your application.
       This may occur if you are calling 'Dispose' on the context instance, or w
      rapping it in a using statement. If you are using dependency injection, yo
      u should let the dependency injection container take care of disposing con
      text instances.
      Object name: 'ApplicationDbContext'.
      Stack Trace:
         at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
         at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
         at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider(
      )
         at Microsoft.EntityFrameworkCore.DbContext.get_ChangeTracker()
         at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.G
      enerateCacheKeyCore(Expression query, Boolean async)
         at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.G
      enerateCacheKey(Expression query, Boolean async)
         at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteCo
      re[TResult](Expression query, Boolean async, CancellationToken cancellatio
      nToken)
         at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteAs
      ync[TResult](Expression query, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryProvider.Exe
      cuteAsync[TResult](Expression expression, CancellationToken cancellationTo
      ken)
         at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.Exe
      cuteAsync[TSource,TResult](MethodInfo operatorMethodInfo, IQueryable`1 sou
      rce, Expression expression, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.Exe
      cuteAsync[TSource,TResult](MethodInfo operatorMethodInfo, IQueryable`1 sou
      rce, LambdaExpression expression, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.Fir
      stAsync[TSource](IQueryable`1 source, Expression`1 predicate, Cancellation
      Token cancellationToken)
         at WhereAreThey.Tests.DonationServiceTests.UpdateDonationStatus_ShouldU
      pdateStatus() in C:\Code\wherearethey\WhereAreThey.Tests\DonationServiceTe
      sts.cs:line 84
      --- End of stack trace from previous location ---
    C:\Code\wherearethey\Services\AlertService.cs(52): error TESTERROR:
      WhereAreThey.Tests.AlertServiceTests.GetMatchingAlerts_ShouldReturnAlertsW
      ithinRadius (7ms): Error Message: System.ObjectDisposedException : Cannot
      access a disposed context instance. A common cause of this error is dispos
      ing a context instance that was resolved from dependency injection and the
      n later trying to use the same context instance elsewhere in your applicat
      ion. This may occur if you are calling 'Dispose' on the context instance,
      or wrapping it in a using statement. If you are using dependency injection
      , you should let the dependency injection container take care of disposing
       context instances.
      Object name: 'ApplicationDbContext'.
      Stack Trace:
         at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
         at Microsoft.EntityFrameworkCore.DbContext.get_ContextServices()
         at Microsoft.EntityFrameworkCore.DbContext.get_InternalServiceProvider(
      )
         at Microsoft.EntityFrameworkCore.DbContext.get_ChangeTracker()
         at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.G
      enerateCacheKeyCore(Expression query, Boolean async)
         at Microsoft.EntityFrameworkCore.Query.CompiledQueryCacheKeyGenerator.G
      enerateCacheKey(Expression query, Boolean async)
         at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteCo
      re[TResult](Expression query, Boolean async, CancellationToken cancellatio
      nToken)
         at Microsoft.EntityFrameworkCore.Query.Internal.QueryCompiler.ExecuteAs
      ync[TResult](Expression query, CancellationToken cancellationToken)
         at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryProvider.Exe
      cuteAsync[TResult](Expression expression, CancellationToken cancellationTo
      ken)
         at Microsoft.EntityFrameworkCore.Query.Internal.EntityQueryable`1.GetAs
      yncEnumerator(CancellationToken cancellationToken)
         at System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`
      1.GetAsyncEnumerator()
         at Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.ToL
      istAsync[TSource](IQueryable`1 source, CancellationToken cancellationToken
      )
         at WhereAreThey.Services.AlertService.GetActiveAlertsAsync(String userI
      dentifier) in C:\Code\wherearethey\Services\AlertService.cs:line 52
         at WhereAreThey.Services.AlertService.GetMatchingAlertsAsync(Double lat
      itude, Double longitude) in C:\Code\wherearethey\Services\AlertService.cs:
      line 70
         at WhereAreThey.Tests.AlertServiceTests.GetMatchingAlerts_ShouldReturnA
      lertsWithinRadius() in C:\Code\wherearethey\WhereAreThey.Tests\AlertServic
      eTests.cs:line 196
      --- End of stack trace from previous location ---
    C:\Code\wherearethey\WhereAreThey.Tests\AlertServiceTests.cs(254): error TESTERROR:
      WhereAreThey.Tests.AlertServiceTests.CreateAlert_ShouldCapRadiusAt160_9 (3
      ms): Error Message: System.ObjectDisposedException : Cannot access a dispo
      sed context instance. A common cause of this error is disposing a context
      instance that was resolved from dependency injection and then later trying
       to use the same context instance elsewhere in your application. This may
      occur if you are calling 'Dispose' on the context instance, or wrapping it
       in a using statement. If you are using dependency injection, you should l
      et the dependency injection container take care of disposing context insta
      nces.
      Object name: 'ApplicationDbContext'.
      Stack Trace:
         at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
         at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
         at Microsoft.EntityFrameworkCore.DbContext.Microsoft.EntityFrameworkCor
      e.Internal.IDbContextDependencies.get_EntityFinderFactory()
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.get_Finder()
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.FindAsync(Obj
      ect[] keyValues)
         at WhereAreThey.Tests.AlertServiceTests.CreateAlert_ShouldCapRadiusAt16
      0_9() in C:\Code\wherearethey\WhereAreThey.Tests\AlertServiceTests.cs:line
       254
      --- End of stack trace from previous location ---
    C:\Code\wherearethey\Services\LocationService.cs(15): error TESTERROR:
      WhereAreThey.Tests.LocationServiceTests.AddLocationReport_Integration_Shou
      ldSendEmailToAlertSubscribers (3ms): Error Message: System.ObjectDisposedE
      xception : Cannot access a disposed context instance. A common cause of th
      is error is disposing a context instance that was resolved from dependency
       injection and then later trying to use the same context instance elsewher
      e in your application. This may occur if you are calling 'Dispose' on the
      context instance, or wrapping it in a using statement. If you are using de
      pendency injection, you should let the dependency injection container take
       care of disposing context instances.
      Object name: 'ApplicationDbContext'.
      Stack Trace:
         at Microsoft.EntityFrameworkCore.DbContext.CheckDisposed()
         at Microsoft.EntityFrameworkCore.DbContext.get_DbContextDependencies()
         at Microsoft.EntityFrameworkCore.DbContext.Microsoft.EntityFrameworkCor
      e.Internal.IDbContextDependencies.get_StateManager()
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.EntryWithoutD
      etectChanges(TEntity entity)
         at Microsoft.EntityFrameworkCore.Internal.InternalDbSet`1.Add(TEntity e
      ntity)
         at WhereAreThey.Services.LocationService.AddLocationReportAsync(Locatio
      nReport report) in C:\Code\wherearethey\Services\LocationService.cs:line 1
      5
         at WhereAreThey.Tests.LocationServiceTests.AddLocationReport_Integratio
      n_ShouldSendEmailToAlertSubscribers() in C:\Code\wherearethey\WhereAreThey
      .Tests\LocationServiceTests.cs:line 292
      --- End of stack trace from previous location ---
Test summary: total: 25, failed: 5, succeeded: 20, skipped: 0, duration: 2.0s
Build failed with 5 error(s) in 4.1s